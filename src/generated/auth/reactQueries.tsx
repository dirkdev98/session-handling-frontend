// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { useApi, AppErrorResponse } from "../common/reactQuery";
import {
QueryKey,
UseMutationOptions,
UseMutationResult,
UseQueryOptions,
UseQueryResult,
useMutation,
useQuery,
useQueryClient,
} from "react-query";
import * as T from "../common/types";
import {
apiAuthLogin,



apiAuthLogout,



apiAuthMe,



apiAuthRefreshTokens,



} from "./apiClient";



interface UseAuthLoginProps {
}
/**
 *  
*/
export function useAuthLogin(
options: UseMutationOptions<T.AuthTokenPairApi, AppErrorResponse, UseAuthLoginProps> = {},
hookOptions: { invalidateQueries?: boolean } = {}, 
): UseMutationResult<T.AuthTokenPairApi, AppErrorResponse, UseAuthLoginProps, unknown> {
const axiosInstance = useApi();
const queryClient = useQueryClient();
if (hookOptions?.invalidateQueries) {
const originalOnSuccess = options.onSuccess;
options.onSuccess = async (data, variables, context) => {
queryClient.invalidateQueries([
"auth",
]);
if (typeof originalOnSuccess === "function") {
return await originalOnSuccess(data, variables, context);
}
};
}
return useMutation(
(variables) => apiAuthLogin(
axiosInstance,
),
options,
);
}



interface UseAuthLogoutProps {
}
/**
 *  
*/
export function useAuthLogout(
options: UseMutationOptions<T.AuthLogoutResponseApi, AppErrorResponse, UseAuthLogoutProps> = {},
hookOptions: { invalidateQueries?: boolean } = {}, 
): UseMutationResult<T.AuthLogoutResponseApi, AppErrorResponse, UseAuthLogoutProps, unknown> {
const axiosInstance = useApi();
const queryClient = useQueryClient();
if (hookOptions?.invalidateQueries) {
const originalOnSuccess = options.onSuccess;
options.onSuccess = async (data, variables, context) => {
queryClient.invalidateQueries([
"auth",
]);
if (typeof originalOnSuccess === "function") {
return await originalOnSuccess(data, variables, context);
}
};
}
return useMutation(
(variables) => apiAuthLogout(
axiosInstance,
),
options,
);
}



/**
 *  
*/
export function useAuthMe<TData = T.AuthMeResponseApi>(opts?: {
options?: UseQueryOptions<T.AuthMeResponseApi, AppErrorResponse, TData> | undefined,
}|undefined) {
const axiosInstance = useApi();
const options = opts?.options ?? {};
return useQuery(useAuthMe.queryKey(
),
({ signal }) => {
return apiAuthMe(
axiosInstance,
{ signal },
);
},
options,
);
}
/**
 * Base key used by useAuthMe.queryKey()
*/
useAuthMe.baseKey = (): QueryKey => ["auth", "me"];
/**
 * Query key used by useAuthMe
*/
useAuthMe.queryKey = (
): QueryKey => [
...useAuthMe.baseKey(),
];



interface UseAuthRefreshTokensProps {
body: T.AuthRefreshTokensBodyInput;
}
/**
 *  
*/
export function useAuthRefreshTokens(
options: UseMutationOptions<T.AuthTokenPairApi, AppErrorResponse, UseAuthRefreshTokensProps> = {},
hookOptions: { invalidateQueries?: boolean } = {}, 
): UseMutationResult<T.AuthTokenPairApi, AppErrorResponse, UseAuthRefreshTokensProps, unknown> {
const axiosInstance = useApi();
const queryClient = useQueryClient();
if (hookOptions?.invalidateQueries) {
const originalOnSuccess = options.onSuccess;
options.onSuccess = async (data, variables, context) => {
queryClient.invalidateQueries([
"auth",
]);
if (typeof originalOnSuccess === "function") {
return await originalOnSuccess(data, variables, context);
}
};
}
return useMutation(
(variables) => apiAuthRefreshTokens(
axiosInstance,
variables.body, 
),
options,
);
}
